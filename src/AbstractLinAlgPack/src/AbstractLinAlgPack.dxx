/** \mainpage AbstractLinAlgPack: Abstract interfaces to basic linear algebra.

The namespace C++ <tt>AbstractLinAlgPack</tt> contains abstract interfaces to linear algebra
vectors and matrices and allow an application to perform linear algebra operations
with these objects without needing to know anything about their special properties.
For example, a numerical optimization or equation solver algorithm can be written
in such a way that it can be used with serial, parallel and other specialized types
of linear algebra libraries and computing environments.  The code in <tt>AbstractLinAlgPack</tt>
is logically broken up into three seperate pieces (and compiled into three separate
libraries).
<ol>

<li> Fundamental vector and matrix interfaces
(<tt>\ref libAbstractLinAlgPack_grp "libAbstractLinAlgPack"</tt>):
This library contains several different vector and matrix interfaces
and includes the bare minimum support software needed for 
default method implementations.  The primary vector
interfaces are <tt>\ref AbstractLinAlgPack::VectorWithOp "VectorWithOp"</tt> and
<tt>\ref AbstractLinAlgPack::VectorWithOpMutable "VectorWithOpMutable"</tt> (derived from <tt>VectorWithOp</tt>).
These vector interfaces represent nonmutable and mutable vectors respectively.
The basic matrix interface compatible with these vector interfaces is
<tt>\ref AbstractLinAlgPack::MatrixWithOp "MatrixWithOp"</tt>.

This library also contains many different useful vector operations that are implemented
using the vector interfaces <tt>VectorWithOp</tt> and <tt>VectorWithOpMutable</tt>.
More and more useful vector operations will be added to this library as they
are needed.  The reason that these vector operations are included in this basic
interface library is that many of the default implementations depend on them.

<li> Auxiliary subclasses and tools based on the fundamental vector and matrix interfaces
(<tt>\ref libAbstractLinAlgPackTools_grp "libAbstractLinAlgPackTools"</tt>):
The classes and other functions in this
library are not fundamental and could be recreated by any developer to meet the needs
of the application.  However, they are included here since it is anticipated that
they will meet the needs of many different developers.  An example of a useful
vector subclass is <tt>\ref AbstractLinAlgPack::VectorWithOpMutableCompositeStd "VectorWithOpMutableCompositeStd"</tt>.
This subclass allows a vector object to be constructed out of a set of <tt>VectorWithOpMutable</tt>
objects and allows for great flexibility.  Some useful and flexible testing software
is also included here that will be of great use to any developer.

</ol>

*/
//@{

/** \defgroup libAbstractLinAlgPack_grp libAbstractLinAlgPack 
\brief Fundamental DVector and Matrix Interfaces.

There are several different levels of foundational vector and matrix interfaces
defined here.

<ul>

<li> DVector interfaces:

Finite-dimensional coordinate vectors are abstracted by the
interfaces <tt>\ref AbstractLinAlgPack::VectorWithOp "VectorWithOp"</tt>
and <tt>\ref AbstractLinAlgPack::VectorWithOpMutable "VectorWithOpMutable"</tt>.
Every vector is a member of a vector space.  DVector spaces are represented in software
as objects with their own abstract interface.  For <tt>VectorWithOpMutable</tt>, the
vector space is represented through the base interface
<tt>\ref AbstractLinAlgPack::VectorSpace "VectorSpace"</tt>.
In software terms, a vector space object primarily acts as an
"Abstract Factory" [Design Patterns, Gamma, et. al., 1995] and derives also from the base interface
<tt>\ref MemMngPack::AbstractFactory "AbstractFactory<VectorWithOpMutable>"</tt>.
In addition to acting as abstact
factories, vector space objects are responsible for determining the compatibility
of vector objects which is useful in debugging an application.  DVector spaces
also provide the definition of the inner product for a vector space.

These finite dimensional coordinate vectors and vector spaces admit a finite dimension
(i.e. <tt>\ref AbstractLinAlgPack::VectorSpace::dim "VectorSpace::dim()"</tt>) and allow access to
arbitrary vector elements (i.e.
<tt>\ref AbstractLinAlgPack::VectorWithOp::get_ele "VectorWithOp::get_ele(i)"</tt>
and <tt>\ref AbstractLinAlgPack::VectorWithOpMutable::set_ele "VectorWithOpMutable::set_ele(i,val)"</tt>).
While any arbibrary vector
operation can be implemented if direct access to the individual elements of vectors are granted,
to do so through virtual function calls on an element-wise basis is unacceptable slow and would
not even be correct in may environments (i.e. parallel programs).  What is needed is a different
way to represent and implement vector reduction and transformation operations that puts the client
(i.e. numerical application developer) in charge while still allowing efficient implementation
in a variety of environments.

The solution to this problem which has been embraced by these vector interfaces is to adopt a <A HREF="../../RTOpPack/html/index.html">
specification for user defined vector reduction/transformation operators </A>.  This design is based on
the "Visitor" design pattern.  A detailed (but slightly out of date) discussion of the underlying design concepts for
this idea can be found at http://dynopt.cheme.cmu.edu/roscoe/RTOp/doc/RTOp.ps .  These vector interfaces accept 
operator objects through to the C++ <tt>RTOpPack::RTOp</tt> interface.  The vector interfaces <tt>VectorWithOp</tt> and
<tt>VectorWithOpMutable</tt> declare the methods
<tt>\ref AbstractLinAlgPack::VectorWithOp::apply_reduction "VectorWithOp::apply_reduction(...)"</tt>
and <tt>\ref AbstractLinAlgPack::VectorWithOpMutable::apply_transformation "VectorWithOpMutable::apply_transformation(...)"</tt>
that accept <tt>RTOp</tt> objects and use them to perform
the desired reduction/transformation operations.  These methods allow great flexibility in how vectors are
used in an application.  The methods <tt>apply_reduction(...)</tt> and <tt>apply_transformation(...)</tt> can be
used to allow vector objects to participate as sub-vectors in a larger composite vector (see
<tt>\ref AbstractLinAlgPack::VectorWithOpMutableCompositeStd "VectorWithOpMutableCompositeStd"</tt>)
or allow only sub-sets of the elements to participate in vector operatations (see
<tt>\ref AbstractLinAlgPack::VectorWithOpMutableSubView "VectorWithOpMutableSubView"</tt>).  All of the other methods that are
associated with these vector interfaces have default implementations based on <tt>apply_reduction(...)</tt> and
<tt>apply_transformation(...)</tt> using default C <tt>RTOp_RTOp</tt> operator classes.  Therefore, to define a very powerful,
fully functional vector subclass, only three methods must be overridden; 
<tt>\ref AbstractLinAlgPack::VectorWithOp::space "VectorWithOp::space()"</tt>
(which requires defining a concreate <tt>\ref AbstractLinAlgPack::VectorSpace "VectorSpace"</tt> class with two pure virtual methods
<tt>\ref AbstractLinAlgPack::VectorSpace::dim "VectorSpace::dim()"</tt> and
<tt>\ref AbstractLinAlgPack::VectorSpace::create_member "VectorSpace::create_member()"</tt>),
<tt>\ref AbstractLinAlgPack::VectorWithOp::apply_reduction "VectorWithOp::apply_reduction(...)"</tt> and
<tt>\ref AbstractLinAlgPack::VectorWithOpMutable::apply_transformation "VectorWithOpMutable::apply_transformation(...)"</tt>.
By far the hardest methods to implement are <tt>apply_reduction(...)</tt> and <tt>apply_transformation(...)</tt>
(which can be combined into a single method in the subclass since they share most of the same features).  Compare this
to most other abstract vector interfaces that require between 20-50 pure virtual methods that most be overridden
(e.g. 26 methods in <A HREF="http://www.cs.sandia.gov/~mheroux/Trilinos/doc/tsf/doc/html/class_tsf__multivector.html">TSF</A>
and 56 methods in <A HREF="http://www.trip.caam.rice.edu/txt/hcldoc/html/HCL_Vector_d.html">HCL</A>).

<li> Matrix interfaces:

ToDo: Discuss operator base interfaces.

The base class for finite dimensional, coordinate based matrices is <tt>\ref AbstractLinAlgPack::MatrixBase "MatrixBase"</tt>.
This base interface contains only dimensionality information for a matrix.  The derived interface
<tt>\ref AbstractLinAlgPack::MatrixWithOp "MatrixWithOp"</tt> contains a whole slew of methods for performing standard
BLAS-like linear algebra operations with a general, possibly rectangular, possibly rank deficient matrix.  Nearly any abstraction
that can be though of as a matrix should be able to implement this interface.  A matrix object primarily acts as an operator that
transforms (linearly) vectors from one vector space to another.
<tt>\ref AbstractLinAlgPack::MatrixWithOpNonsingular "MatrixWithOpNonsingular"</tt> is a specialization of <tt>MatrixWithOp</tt>
for matrices that are square and nonsingular.  This interface adds methods for solving for linear systems involving the matrix.
While these matrix interfaces meet most of the needs of a numerical algorithm, there are some types of methods that can only
by implemented by a symmetric matrix.  For example, the operations like <tt>C = b*C + B'*A*B</tt> and <tt>C = b*C + B'*inv(A)*B</tt>
are only guaranteed to preserve the symmetry of the lhs matrix \a C if the matrix \a A is also symmetric.  To handle these types
of specialized operations, symmetric matrix interface <tt>\ref AbstractLinAlgPack::MatrixSymWithOp "MatrixSymWithOp"</tt> and
<tt>\ref AbstractLinAlgPack::MatrixSymWithOpNonsingular "MatrixSymWithOpNonsingular"</tt> are also included.  This design makes
use of multiple inheritance so that all of the logical relationships between matrix types is preserved in the code.  For example,
a nonsingular symmetric matrix satisfies all of the minimum properties of an unsymmetric nonsingular matrix, so it derived from
the <tt>MatrixWithOpNonsingular</tt> interface as well as from the <tt>MatrixSymWithOp</tt> interface.  This is an example
of where multiple inheritance is needed accuratly model the application domain.

A very specialized type of matrix implementation is one where the rows and/or columns and/or diagonals of a matrix can be
individualy accessed as a client.  To support these types of matrices in an abstract manner, the interfaces
<tt>\ref AbstractLinAlgPack::MultiVector "MultiVector"</tt> and <tt>\ref AbstractLinAlgPack::MultiVectorMutable "MultiVectorMutable"</tt>
are defined.  Since a multi-vector satisfies all of the properties of a matrix, it supports the <tt>MatrixWithOp</tt> interface.
Multi-vectors are so critical to the optimal performance of many applications that it is required that every
<tt>\ref AbstractLinAlgPack::VectorSpace "VectorSpace"</tt> object is required to be able to create multi-vector objects
in addition to vector objects.

The <tt>MatrixWithOp</tt> interface assumes that
matrix-vector multiplication with the original matrix <tt>y = M*x</tt> and its transpose <tt>y = M'*x</tt> can both be performed.
The basic assumption that the untransposed and transposed operator are both allowed somewhat limits the types of <tt>MatrixWithOp</tt>
subclasses that can be correctly and efficiently implemented.  Unlike other interfaces that encourage developers to selectively
disallow implementations of certain operations, these interfaces assume almost universally that every published method must have
a correct implementation in the subclass.  There are some race cases where a subclass may refuse to implement a method but in
general this is not allowed. 

<li> Miscellaneous vector operations.

A set of functions for miscellaneous vector operations based on the RTOp operator classes in 
<A HREF="../../RTOpStdOpsLib/html/index.html">libRTOpStdOpsLib</A> is declared in VectorStdOps.hpp
and documented \ref VectorStdOps_grp "here".  As more general vector opeations are needed, they
will be added to this header file.

</ul>

*/

/** \defgroup libAbstractLinAlgPackTools_grp libAbstractLinAlgPackTools
\brief Auxiliary Subclasses and Tools.

One particularly useful vector subclass is <tt>\ref AbstractLinAlgPack::VectorWithOpMutableCompositeStd "VectorWithOpComposite"</tt>.
This vector subclass allows a vector object to be created out of the concatonation of two or more other vector
objects.  In most situations this is a near optimal implementation of such a composite vector.

A major task in any development effort is testing.  Therefore, included in this library is a default
testing class for the <tt>\ref AbstractLinAlgPack::VectorSpace "VectorSpace"</tt>,
<tt>\ref AbstractLinAlgPack::VectorWithOp "VectorWithOp"</tt> and
<tt>\ref AbstractLinAlgPack::VectorWithOpMutable "VectorWithOpMutable"</tt> interfaces called
<tt>\ref AbstractLinAlgPack::VectorSpaceTester "VectorSpaceTester"</tt>.  This testing class performs some moderately
though tests and have several options that can change its behavior.  To facilitate setting these options from
and options file the subclass <tt>\ref AbstractLinAlgPack::VectorSpaceTesterSetOptions "VectorSpaceTesterSetOptions"</tt>
is included.  When developing new subclasses for the fundamental vector interfaces, this testing class will
become very familiar to the developers who do the debugging.

*/

//@}
