
********************************************************************
*** Algorithm iteration detailed journal output                  ***
***                                                              ***
*** Below, detailed information about the SQP algorithm is given ***
*** while it is running.  The amount of information that is      ***
*** produced can be specified using the option                   ***
*** NLPSolverClientInterface::journal_output_level (the default ***
*** is PRINT_NOTHING and produces no output                      ***
********************************************************************

*** Echoing input options ...

begin_options

options_group DecompositionSystemStateStepBuilderStd {
    null_space_matrix = EXPLICIT;
    range_space_matrix = ORTHOGONAL;
}

options_group NLPAlgoConfigMamaJama {
    line_search_method = FILTER;
    quasi_newton = BFGS;
}

options_group NLPSolverClientInterface {
    calc_conditioning = true;
    calc_matrix_info_null_space_only = true;
    calc_matrix_norms = true;
    feas_tol = 1e-7;
    journal_output_level = PRINT_ALGORITHM_STEPS;
    journal_print_digits = 10;
    max_iter = 20;
    max_run_time = 2.0;
    null_space_journal_output_level = PRINT_ITERATION_QUANTITIES;
    opt_tol = 1e-2;
}

end_options


*** Setting up to run MOOCHO on the NLP using a configuration object of type 'class MoochoPack::NLPAlgoConfigMamaJama' ...

test_nlp = true: Testing the NLP! ...

Testing the supported NLPFirstOrder interface ...

*********************************
*** test_nlp_first_order(...) ***
*********************************

Testing the vector spaces ...

Testing nlp->space_x() ...
nlp->space_x() checks out!

Testing nlp->space_c() ...
nlp->space_c() checks out!

**************************************
*** NLPTester::test_interface(...) ***
**************************************

nlp->force_xinit_in_bounds(true)
nlp->initialize(true)

*** Dimensions of the NLP ...

nlp->n()  = 3005
nlp->m()  = 3000

*** Validate the dimensions of the vector spaces ...

check: nlp->space_x()->dim() = 3005 == nlp->n() = 3005: true

check: nlp->space_c()->dim() = 3000 == nlp->m() = 3000: true

*** Validate that the initial starting point is in bounds ...

||nlp->xinit()||inf = 1.00000000e-001

check: xl <= x <= xu : true
xinit is in bounds with { max |u| | xl <= x + u <= xu } -> 1.00000000e+050

check: num_bounded(nlp->xl(),nlp->xu()) = 5 == nlp->num_bounded_x() = 5: true

Getting the initial estimates for the Lagrange mutipliers ...

||lambda||inf  = 0.00000000e+000
||nu||inf      = 0.00000000e+000
nu.nz()        = 0

*** Evaluate the point xo ...

||xo||inf = 1.00000000e-001

f(xo) = 1.50250000e+001
||c(xo)||inf = 1.19973085e+002

*** Report this point to the NLP as suboptimal ...

*** Print the number of evaluations ...

nlp->num_f_evals() = 1
nlp->num_c_evals() = 1

Calling nlp->calc_Gc(...) at nlp->xinit() ...

Calling nlp->calc_Gf(...) at nlp->xinit() ...

Comparing directional products Gf'*y and/or Gc'*y with finite difference values  FDGf'*y and/or FDGc'*y for random y's ...

****
**** Random directional vector 1 ( ||y||_1 / n = 6.98292776e-001 )
***

rel_err(Gf'*y,FDGf'*y) = rel_err(-2.09836979e+002,-2.09836979e+002) = 3.31844121e-015

rel_err(sum(Gc'*y),sum(FDGc'*y)) = rel_err(-2.72894778e+006,-2.72894778e+006) = 5.11913006e-016

Congradulations!  All of the computed errors were within the specified error tolerance!

Successful end of testing of the nlp

************************************
*** MoochoSolver::solve_nlp()    ***
************************************

*** Starting iterations ...


(0) 1: "EvalNewPoint"

x is not updated for any k so set x_k = nlp.xinit() ...

||x_k||inf            = 1.0000000000e-001

Updating the decomposition ...

DecompositionSystemVarReductPerm object currently does not have a basis so we must select one ...

The NLP will attempt to select a basis (k = 0)...

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Must allocate a new matrix object for D = -inv(C)*N since one has not been allocated yet ...

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

Must allocate a new basis matrix object for C since one has not been allocated yet ...

Allocated a new basis matrix object C of type 'class AbstractLinAlgPack::MatrixOpNonsingAggr' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Using a direct sparse solver to set a new basis ...

Using LAPACK xGETRF to analyze and factor a new matrix ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 1.5025000000e+001
||Gf_k||inf              = 1.0000000000e-001
||Gf_k(var_dep)_k||inf   = 1.0000000000e-001
||Gf_k(var_indep)_k||inf = 1.0000000000e-001
||c_k||inf               = 1.1997308452e+002

Gf(var_indep)_k =
  5
   0.1:1 0.1:2 0.1:3 0.1:4 0.1:5

(0) 2: "QuasiNormalStep"

||py||   = 4.7998936932e-003

||Ypy||2 = 1.1999603325e+000

(0) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 4.0008087749e-005

num_basis_k was updated so the basis changed so we will skip this check
    reset min ||py||/||c|| to current value + 1

(0) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.3784529074e-011 / (1.1997308452e+002 + 2.2250738585e-308)
     = 1.1489684648e-013

num_basis_k was updated so the basis changed so we will skip this check
    reset min ||R*py+c||/||c|| to current value + epsilon(2.2204460493e-016)

(0) 3: "ReducedGradient"

||rGf||inf = 1.0809594644e+001

rGf_k =
  5
   -10.8086:1 -10.8091:2 -10.8091:3 -10.8091:4 -10.8096:5

(0) 4.-1: "CheckSkipBFGSUpdate"

(0) 4: "ReducedHessian"

Initializing rHL = eye(n-r) (k = 0)...

||rHL_k||inf    = 1.0000000000e+000

cond_inf(rHL_k) = 1.0000000000e+000

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     1:1:1 -593.779:1:2 1:1:3 0:1:4 0:1:5
     0:2:1 1:2:2 -592.124:2:3 1:2:4 0:2:5
     0:3:1 0:3:2 1:3:3 -590.468:3:4 1:3:5
     0:4:1 0:4:2 0:4:3 1:4:4 -588.812:4:5
     0:5:1 0:5:2 0:5:3 0:5:4 1:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     1:1:1 0:1:2 0:1:3 0:1:4 0:1:5
     -593.779:2:1 1:2:2 0:2:3 0:2:4 0:2:5
     1:3:1 -592.124:3:2 1:3:3 0:3:4 0:3:5
     0:4:1 1:4:2 -590.468:4:3 1:4:4 0:4:5
     0:5:1 0:5:2 1:5:3 -588.812:5:4 1:5:5

(0) 5.-1: "SetDBoundsStd"

(0) 5: "TangentialStep"

qp_grad_k = 
  5
   -10.8086:1 -10.8091:2 -10.8091:3 -10.8091:4 -10.8096:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 5.2360290589e-001

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 1.0809594644e+001

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 1.0809594644e+001

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 0
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 1.0809594644e+001
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 0
max(|lambda_breve(i)|)  = 0.0000000000e+000
min(|lambda_breve(i)|)  = 0.0000000000e+000

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 1.0809594644e+001
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+000
||Zpz_k||2     = 1.1032346914e+002

pz_k = 
  5
   10.8086:1 10.8091:2 10.8091:3 10.8091:4 10.8096:5

(0) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.3207213101e-012)/(1.1999603325e+000 * 1.1032346914e+002 + 2.2250738585e-308)
  = -9.9764581665e-015

||d||inf = 1.0285991738e+001

(0) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 1.0809594644e+001

(0) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.1000000000e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 9.8269042215e+000 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 1.1997308452e+002 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 9.3509015798e+000 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 0) :-(

(0) 9.-1: "LineSearchFullStep"

f_k        = 1.5025000000e+001
||c_k||inf = 1.1997308452e+002
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 1.0385991738e+001

f_kp1        = 5.5154949366e+003
||c_kp1||inf = 2.4039402261e+005

(0) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.1792252057e+002

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
Filter is empty.

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 5.5154949366e+003 2.3625283841e+005          failed      Fraction Reduction (! Switch Cond )|
|5.0000000000e-001 1.2436714997e+003 3.3614573874e+004          failed      Fraction Reduction (! Switch Cond )|
|2.5000000000e-001 2.4895113274e+002 5.1562325845e+003          failed      Fraction Reduction (! Switch Cond )|
|1.2500000000e-001 3.6888787086e+001 8.1127274965e+002          failed      Fraction Reduction (! Switch Cond )|
|6.2500000000e-002 2.1820737219e+000 6.8472167804e+001        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 2.1820737219e+000 - 1.0000000000e-005*6.8472167804e+001 = 2.1813890002e+000
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*6.8472167804e+001 = 6.8471483083e+001

(1) 1: "EvalNewPoint"

||x_k||inf            = 7.4287448361e-001
||x(var_dep)_k||inf   = 2.3136269747e-002
||x(var_indep)_k||inf = 7.4287448361e-001

x(var_indep)_k = 
  5
   0.742812:1 0.742843:2 0.742843:3 0.742843:4 0.742874:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 2.1820737219e+000
||Gf_k||inf              = 7.4287448361e-001
||Gf_k(var_dep)_k||inf   = 2.3136269747e-002
||Gf_k(var_indep)_k||inf = 7.4287448361e-001
||c_k||inf               = 6.9682547090e+001

Gf(var_indep)_k =
  5
   0.742812:1 0.742843:2 0.742843:3 0.742843:4 0.742874:5

(1) 2: "QuasiNormalStep"

||py||   = 1.6259405998e-002

||Ypy||2 = 1.0621477516e+000

(1) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 2.3333541435e-004

(1) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.8212102633e-013 / (6.9682547090e+001 + 2.2250738585e-308)
     = 9.7889795195e-015

(1) 3: "ReducedGradient"

||rGf||inf = 3.7462461296e-001

rGf_k =
  5
   0.374625:1 0.374464:2 0.374464:3 0.374464:4 0.374303:5

(1) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(2.4169862058e+001+6.4588832268e+003))
        * (1.1032346914e+002/1.1999603325e+000)
      = 1.1418557184e+001
ratio > 1
Perform BFGS update if you can ...

(1) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 1.1183897541e+001

||s_bfgs||inf = 6.7559966523e-001

y_bfgs =
  5
   11.1832:1 11.1836:2 11.1836:3 11.1836:4 11.1839:5

s_bfgs =
  5
   0.675537:1 0.675568:2 0.675568:3 0.675568:4 0.6756:5

Rescaling the initial identity matrix before the update as:
Iscale = (y'*y)/(y'*s) = (6.2535947673e+002)/(3.7776268532e+001) = 1.6554294562e+001
B =  Iscale * eye(n-r) ...

B after rescaling = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     16.5543:1:1 -593.779:1:2 4.0687:1:3 0:1:4 0:1:5
     0:2:1 16.5543:2:2 -592.124:2:3 4.0687:2:4 0:2:5
     0:3:1 0:3:2 16.5543:3:3 -590.468:3:4 4.0687:3:5
     0:4:1 0:4:2 0:4:3 16.5543:4:4 -588.812:4:5
     0:5:1 0:5:2 0:5:3 0:5:4 16.5543:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     4.0687:1:1 0:1:2 0:1:3 0:1:4 0:1:5
     -593.779:2:1 4.0687:2:2 0:2:3 0:2:4 0:2:5
     16.5543:3:1 -592.124:3:2 4.0687:3:3 0:3:4 0:3:5
     0:4:1 16.5543:4:2 -590.468:4:3 4.0687:4:4 0:4:5
     0:5:1 0:5:2 16.5543:5:3 -588.812:5:4 4.0687:5:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 3.7776268532e+001 >=  s_bfgs' * B * s_bfgs = 3.7776268535e+001
Perform the undamped update ...

B after the BFGS update = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     16.5544:1:1 2.23614:1:2 4.0687:1:3 2.85463e-009:1:4 1.95474e-009:1:5
     5.27915e-005:2:1 16.5543:2:2 2.00002:2:3 4.0687:2:4 1.05485e-009:2:5
     5.27878e-005:3:1 1.1783e-008:3:2 16.5543:3:3 1.73208:3:4 4.0687:3:5
     5.27841e-005:4:1 8.12156e-009:4:2 4.46017e-009:4:3 16.5543:4:4 1.41425:4:5
     -4.02538e-009:5:1 -5.27841e-005:5:2 -5.27878e-005:5:3 -5.27914e-005:5:4 16.5542:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     4.06871:1:1 1.2975e-005:1:2 1.29741e-005:1:3 1.29732e-005:1:4 -9.89349e-010:1:5
     2.23614:2:1 4.0687:2:2 2.85463e-009:2:3 1.95474e-009:2:4 -1.29732e-005:2:5
     16.5543:3:1 2.00002:3:2 4.0687:3:3 1.05485e-009:3:4 -1.29741e-005:3:5
     1.1783e-008:4:1 16.5543:4:2 1.73208:4:3 4.0687:4:4 -1.2975e-005:4:5
     8.12156e-009:5:1 4.46017e-009:5:2 16.5543:5:3 1.41425:5:4 4.06868:5:5

||rHL_k||inf    = 1.6554558493e+001

cond_inf(rHL_k) = 1.0000318885e+000

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     16.5544:1:1 2.23614:1:2 4.0687:1:3 2.85463e-009:1:4 1.95474e-009:1:5
     5.27915e-005:2:1 16.5543:2:2 2.00002:2:3 4.0687:2:4 1.05485e-009:2:5
     5.27878e-005:3:1 1.1783e-008:3:2 16.5543:3:3 1.73208:3:4 4.0687:3:5
     5.27841e-005:4:1 8.12156e-009:4:2 4.46017e-009:4:3 16.5543:4:4 1.41425:4:5
     -4.02538e-009:5:1 -5.27841e-005:5:2 -5.27878e-005:5:3 -5.27914e-005:5:4 16.5542:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     4.06871:1:1 1.2975e-005:1:2 1.29741e-005:1:3 1.29732e-005:1:4 -9.89349e-010:1:5
     2.23614:2:1 4.0687:2:2 2.85463e-009:2:3 1.95474e-009:2:4 -1.29732e-005:2:5
     16.5543:3:1 2.00002:3:2 4.0687:3:3 1.05485e-009:3:4 -1.29741e-005:3:5
     1.1783e-008:4:1 16.5543:4:2 1.73208:4:3 4.0687:4:4 -1.2975e-005:4:5
     8.12156e-009:5:1 4.46017e-009:5:2 16.5543:5:3 1.41425:5:4 4.06868:5:5

(1) 5.-1: "SetDBoundsStd"

(1) 5: "TangentialStep"

qp_grad_k = 
  5
   0.374625:1 0.374464:2 0.374464:3 0.374464:4 0.374303:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 2.5901993894e-001

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 2.2629695306e-002

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 2.2629695306e-002

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 0
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 2.2629695306e-002
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 0
max(|lambda_breve(i)|)  = 0.0000000000e+000
min(|lambda_breve(i)|)  = 0.0000000000e+000

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 2.2629695306e-002
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+000
||Zpz_k||2     = 6.0331754008e-002

pz_k = 
  5
   -0.0226297:1 -0.0226203:2 -0.0226203:3 -0.0226203:4 -0.022611:5

(1) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.9715132304e-015)/(1.0621477516e+000 * 6.0331754008e-002 + 2.2250738585e-308)
  = -3.0765842339e-014

||d||inf = 2.8163092161e-001

(1) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.7462461296e-001

(1) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.7428744836e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.1494640979e-001 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 6.9682547090e+001 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 1.6158990464e-001 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 1) :-(

(1) 9.-1: "LineSearchFullStep"

f_k        = 2.1820737219e+000
||c_k||inf = 6.9682547090e+001
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 4.6135478069e-001

f_kp1        = 6.1576438692e-001
||c_kp1||inf = 1.5830011682e+001

(1) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 6.8472167804e+001

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        2.1813890002e+000         6.8471483083e+001|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 6.1576438692e-001 1.5552264182e+001        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 6.1576438692e-001 - 1.0000000000e-005*1.5552264182e+001 = 6.1560886428e-001
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*1.5552264182e+001 = 1.5552108660e+001

Removing from the filter the redundant point:
  f_with_boundary     = 2.1813890002e+000
  theta_with_boundary = 6.8471483083e+001
  iteration added     = 0

(2) 1: "EvalNewPoint"

||x_k||inf            = 4.6135478069e-001
||x(var_dep)_k||inf   = 7.4771752444e-003
||x(var_indep)_k||inf = 4.6135478069e-001

x(var_indep)_k = 
  5
   0.461355:1 0.461299:2 0.461299:3 0.461299:4 0.461244:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 6.1576438692e-001
||Gf_k||inf              = 4.6135478069e-001
||Gf_k(var_dep)_k||inf   = 7.4771752444e-003
||Gf_k(var_indep)_k||inf = 4.6135478069e-001
||c_k||inf               = 1.5830011682e+001

Gf(var_indep)_k =
  5
   0.461355:1 0.461299:2 0.461299:3 0.461299:4 0.461244:5

(2) 2: "QuasiNormalStep"

||py||   = 7.0350662441e-003

||Ypy||2 = 3.9705009790e-001

(2) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 4.4441320608e-004

(2) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 2.3092638912e-014 / (1.5830011682e+001 + 2.2250738585e-308)
     = 1.4587884946e-015

(2) 3: "ReducedGradient"

||rGf||inf = 4.1554627380e-001

rGf_k =
  5
   0.415546:1 0.415437:2 0.415437:3 0.415437:4 0.415329:5

(2) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(8.3732647964e-001+3.7503756046e+003))
        * (6.0331754008e-002/1.0621477516e+000)
      = 9.2741722769e-003
ratio < 1
Skipping BFGS update ...

rHL_k = rHL_km1

(2) 4: "ReducedHessian"

The matrix rHL_k has already been updated so leave it

(2) 5.-1: "SetDBoundsStd"

(2) 5: "TangentialStep"

qp_grad_k = 
  5
   0.415546:1 0.415437:2 0.415437:3 0.415437:4 0.415329:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 4.3200066153e-002

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 2.5101622321e-002

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 2.5101622321e-002

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 0
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 2.5101622321e-002
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 0
max(|lambda_breve(i)|)  = 0.0000000000e+000
min(|lambda_breve(i)|)  = 0.0000000000e+000

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 2.5101622321e-002
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+000
||Zpz_k||2     = 5.7849459762e-002

pz_k = 
  5
   -0.0251016:1 -0.0250955:2 -0.0250955:3 -0.0250955:4 -0.0250893:5

(2) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-3.2742905609e-016)/(3.9705009790e-001 * 5.7849459762e-002 + 2.2250738585e-308)
  = -1.4255176574e-014

||d||inf = 6.8289342521e-002

(2) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 4.1554627380e-001

(2) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.4613547807e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.8435687164e-001 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 1.5830011682e+001 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 4.6733716607e-002 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 2) :-(

(2) 9.-1: "LineSearchFullStep"

f_k        = 6.1576438692e-001
||c_k||inf = 1.5830011682e+001
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 3.9314710830e-001

f_kp1        = 3.8695300275e-001
||c_kp1||inf = 1.3445285133e+000

(2) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.5552264182e+001

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        6.1560886428e-001         1.5552108660e+001|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 3.8695300275e-001 1.3201800917e+000        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.8695300275e-001 - 1.0000000000e-005*1.3201800917e+000 = 3.8693980095e-001
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*1.3201800917e+000 = 1.3201668899e+000

Removing from the filter the redundant point:
  f_with_boundary     = 6.1560886428e-001
  theta_with_boundary = 1.5552108660e+001
  iteration added     = 1

(3) 1: "EvalNewPoint"

||x_k||inf            = 3.9314710830e-001
||x(var_dep)_k||inf   = 6.9887237779e-004
||x(var_indep)_k||inf = 3.9314710830e-001

x(var_indep)_k = 
  5
   0.393147:1 0.393051:2 0.393051:3 0.393051:4 0.392954:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.8695300275e-001
||Gf_k||inf              = 3.9314710830e-001
||Gf_k(var_dep)_k||inf   = 6.9887237779e-004
||Gf_k(var_indep)_k||inf = 3.9314710830e-001
||c_k||inf               = 1.3445285133e+000

Gf(var_indep)_k =
  5
   0.393147:1 0.393051:2 0.393051:3 0.393051:4 0.392954:5

(3) 2: "QuasiNormalStep"

||py||   = 6.9845040071e-004

||Ypy||2 = 3.8222397636e-002

(3) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 5.1947607941e-004

(3) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.1102230246e-015 / (1.3445285133e+000 + 2.2250738585e-308)
     = 8.2573408721e-016

(3) 3: "ReducedGradient"

||rGf||inf = 3.9272839189e-001

rGf_k =
  5
   0.392728:1 0.392631:2 0.392631:3 0.392631:4 0.392533:5

(3) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(9.2894644415e-001+8.5183273306e+002))
        * (5.7849459762e-002/3.9705009790e-001)
      = 4.9893062465e-002
ratio < 1
Skipping BFGS update ...

rHL_k = rHL_km1

(3) 4: "ReducedHessian"

The matrix rHL_k has already been updated so leave it

(3) 5.-1: "SetDBoundsStd"

(3) 5: "TangentialStep"

qp_grad_k = 
  5
   0.392728:1 0.392631:2 0.392631:3 0.392631:4 0.392533:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 4.2053082371e-004

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 2.3723277979e-002

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 2.3723277979e-002

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 0
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 2.3723277979e-002
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 0
max(|lambda_breve(i)|)  = 0.0000000000e+000
min(|lambda_breve(i)|)  = 0.0000000000e+000

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 2.3723277979e-002
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+000
||Zpz_k||2     = 5.3050520400e-002

pz_k = 
  5
   -0.0237233:1 -0.0237178:2 -0.0237178:3 -0.0237178:4 -0.0237123:5

(3) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-1.0554030523e-018)/(3.8222397636e-002 * 5.3050520400e-002 + 2.2250738585e-308)
  = -5.2048805987e-016

||d||inf = 2.4141742846e-002

(3) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.9272839189e-001

(3) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.3931471083e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.8190015939e-001 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 1.3445285133e+000 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 1.7328925784e-002 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 3) :-(

(3) 9.-1: "LineSearchFullStep"

f_k        = 3.8695300275e-001
||c_k||inf = 1.3445285133e+000
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 3.6900536545e-001

f_kp1        = 3.4024364074e-001
||c_kp1||inf = 4.4987367193e-002

(3) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.3201800917e+000

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        3.8693980095e-001         1.3201668899e+000|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 3.4024364074e-001 4.4177631526e-002        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.4024364074e-001 - 1.0000000000e-005*4.4177631526e-002 = 3.4024319897e-001
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*4.4177631526e-002 = 4.4177189749e-002

Removing from the filter the redundant point:
  f_with_boundary     = 3.8693980095e-001
  theta_with_boundary = 1.3201668899e+000
  iteration added     = 2

(4) 1: "EvalNewPoint"

||x_k||inf            = 3.6900536545e-001
||x(var_dep)_k||inf   = 2.4215783810e-005
||x(var_indep)_k||inf = 3.6900536545e-001

x(var_indep)_k = 
  5
   0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.4024364074e-001
||Gf_k||inf              = 3.6900536545e-001
||Gf_k(var_dep)_k||inf   = 2.4215783810e-005
||Gf_k(var_indep)_k||inf = 3.6900536545e-001
||c_k||inf               = 4.4987367193e-002

Gf(var_indep)_k =
  5
   0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

(4) 2: "QuasiNormalStep"

||py||   = 2.4215765620e-005

||Ypy||2 = 1.3249505872e-003

(4) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 5.3827923550e-004

(4) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 3.4694469520e-017 / (4.4987367193e-002 + 2.2250738585e-308)
     = 7.7120471110e-016

(4) 3: "ReducedGradient"

||rGf||inf = 3.6900485363e-001

rGf_k =
  5
   0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

(4) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(8.7794944328e-001+7.2309266475e+001))
        * (5.3050520400e-002/3.8222397636e-002)
      = 1.6223856969e+000
ratio > 1
Perform BFGS update if you can ...

(4) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.3723538254e-002

||s_bfgs||inf = 2.3723277979e-002

y_bfgs =
  5
   -0.0237235:1 -0.023718:2 -0.023718:3 -0.023718:4 -0.0237125:5

s_bfgs =
  5
   -0.0237233:1 -0.0237178:2 -0.0237178:3 -0.0237178:4 -0.0237123:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 2.8126935606e-003 <  s_bfgs' * B * s_bfgs = 4.6561647149e-002
Dampen the update ...
theta = 8.5143334100e-001
y_bfgs = theta*y_bfgs + (1-theta)*B*s_bfgs ...
||y_bfgs||inf = 7.8545356511e-002
y_bfgs =
  5
   -0.0785454:1 -0.0785262:2 -0.0785262:3 -0.0785262:4 -0.078507:5

B after the BFGS update = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.9044:1:1 4.58126:1:2 3.66071:1:3 -0.861437:1:4 -0.861437:1:5
     -2.64929:2:1 13.9056:2:2 3.6874:2:3 3.55791:2:4 -1.0949:2:5
     -2.64929:3:1 -2.64869:3:2 13.9056:3:3 2.79243:3:4 3.38525:3:5
     -2.64929:4:1 -2.64869:4:2 -2.64869:4:3 13.9056:4:4 1.89695:4:5
     -2.64869:5:1 -2.64808:5:2 -2.64808:5:3 -2.64808:5:4 13.9068:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.72886:1:1 -0.710484:1:2 -0.710484:1:3 -0.710484:1:4 -0.710321:1:5
     4.58126:2:1 3.66071:2:2 -0.861437:2:3 -0.861437:2:4 -0.86124:2:5
     13.9056:3:1 3.6874:3:2 3.55791:3:3 -1.0949:3:4 -1.09465:3:5
     -2.64869:4:1 13.9056:4:2 2.79243:4:3 3.38525:4:4 -1.50452:4:5
     -2.64869:5:1 -2.64869:5:2 13.9056:5:3 1.89695:5:4 3.03294:5:5

||rHL_k||inf    = 2.4499747866e+001

cond_inf(rHL_k) = 7.4011738690e+000

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.9044:1:1 4.58126:1:2 3.66071:1:3 -0.861437:1:4 -0.861437:1:5
     -2.64929:2:1 13.9056:2:2 3.6874:2:3 3.55791:2:4 -1.0949:2:5
     -2.64929:3:1 -2.64869:3:2 13.9056:3:3 2.79243:3:4 3.38525:3:5
     -2.64929:4:1 -2.64869:4:2 -2.64869:4:3 13.9056:4:4 1.89695:4:5
     -2.64869:5:1 -2.64808:5:2 -2.64808:5:3 -2.64808:5:4 13.9068:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.72886:1:1 -0.710484:1:2 -0.710484:1:3 -0.710484:1:4 -0.710321:1:5
     4.58126:2:1 3.66071:2:2 -0.861437:2:3 -0.861437:2:4 -0.86124:2:5
     13.9056:3:1 3.6874:3:2 3.55791:3:3 -1.0949:3:4 -1.09465:3:5
     -2.64869:4:1 13.9056:4:2 2.79243:4:3 3.38525:4:4 -1.50452:4:5
     -2.64869:5:1 -2.64869:5:2 13.9056:5:3 1.89695:5:4 3.03294:5:5

(4) 5.-1: "SetDBoundsStd"

(4) 5: "TangentialStep"

qp_grad_k = 
  5
   0.369005:1 0.368913:2 0.368913:3 0.368913:4 0.368821:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 5.1410422885e-007

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 1.1145113136e-001

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 1.1145113136e-001

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 0
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 1.1145113136e-001
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 0
max(|lambda_breve(i)|)  = 0.0000000000e+000
min(|lambda_breve(i)|)  = 0.0000000000e+000

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 1.1145113136e-001
nu_k.nz()      = 0
max(|nu_k(i)|) = 0.0000000000e+000
||Zpz_k||2     = 2.4915426691e-001

pz_k = 
  5
   -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

(4) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-9.7541137832e-021)/(1.3249505872e-003 * 2.4915426691e-001 + 2.2250738585e-308)
  = -2.9547436387e-017

||d||inf = 1.1145164318e-001

(4) 7: "CalcReducedGradLagrangian"

||rGL_k||inf = 3.6900485363e-001

(4) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.3690053654e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.6954229906e-001 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 4.4987367193e-002 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 8.1410669372e-002 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 4) :-(

(4) 9.-1: "LineSearchFullStep"

f_k        = 3.4024364074e-001
||c_k||inf = 4.4987367193e-002
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 2.5755372227e-001

f_kp1        = 1.6574989579e-001
||c_kp1||inf = 6.1791102848e-003

(4) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 4.4177631526e-002

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        3.4024319897e-001         4.4177189749e-002|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 1.6574989579e-001 6.0687208500e-003        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 1.6574989579e-001 - 1.0000000000e-005*6.0687208500e-003 = 1.6574983511e-001
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*6.0687208500e-003 = 6.0686601628e-003

Removing from the filter the redundant point:
  f_with_boundary     = 3.4024319897e-001
  theta_with_boundary = 4.4177189749e-002
  iteration added     = 3

(5) 1: "EvalNewPoint"

||x_k||inf            = 2.5755372227e-001
||x(var_dep)_k||inf   = 3.9415362886e-006
||x(var_indep)_k||inf = 2.5755372227e-001

x(var_indep)_k = 
  5
   0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 1.6574989579e-001
||Gf_k||inf              = 2.5755372227e-001
||Gf_k(var_dep)_k||inf   = 3.9415362886e-006
||Gf_k(var_indep)_k||inf = 2.5755372227e-001
||c_k||inf               = 6.1791102848e-003

Gf(var_indep)_k =
  5
   0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

(5) 2: "QuasiNormalStep"

||py||   = 3.9415361956e-006

||Ypy||2 = 2.1569444240e-004

(5) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 6.3788086213e-004

(5) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.9388939039e-018 / (6.1791102848e-003 + 2.2250738585e-308)
     = 1.1229600354e-015

(5) 3: "ReducedGradient"

||rGf||inf = 2.5755370750e-001

rGf_k =
  5
   0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

(5) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(8.2491431895e-001+2.4197092553e+000))
        * (2.4915426691e-001/1.3249505872e-003)
      = 1.0439663191e+003
ratio > 1
Perform BFGS update if you can ...

(5) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 1.1145114613e-001

||s_bfgs||inf = 1.1145113136e-001

y_bfgs =
  5
   -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

s_bfgs =
  5
   -0.111451:1 -0.111425:2 -0.111425:3 -0.111425:4 -0.111399:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 6.2077810439e-002 >=  s_bfgs' * B * s_bfgs = 2.0553084537e-001
Perform the undamped update ...

B after the BFGS update = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.442:1:1 8.19625:1:2 3.56695:1:3 -1.07406:1:4 -1.07406:1:5
     -3.11158:2:1 13.4434:2:2 6.42804:2:3 3.4014:2:4 -1.4655:2:5
     -3.11158:3:1 -3.11086:3:2 13.4434:3:3 4.65375:3:4 3.0695:3:5
     -3.11158:4:1 -3.11086:4:2 -3.11086:4:3 13.4434:4:4 2.86651:4:5
     -3.11086:5:1 -3.11013:5:2 -3.11013:5:3 -3.11013:5:4 13.4449:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.66633:1:1 -0.848692:1:2 -0.848692:1:3 -0.848692:1:4 -0.848494:1:5
     8.19625:2:1 3.56695:2:2 -1.07406:2:3 -1.07406:2:4 -1.07381:2:5
     13.4434:3:1 6.42804:3:2 3.4014:3:3 -1.4655:3:4 -1.46516:3:5
     -3.11086:4:1 13.4434:4:2 4.65375:4:3 3.0695:4:4 -2.3231:4:5
     -3.11086:5:1 -3.11086:5:2 13.4434:5:3 2.86651:5:4 2.00709:5:5

||rHL_k||inf    = 2.5886144627e+001

cond_inf(rHL_k) = 2.5891815803e+001

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.442:1:1 8.19625:1:2 3.56695:1:3 -1.07406:1:4 -1.07406:1:5
     -3.11158:2:1 13.4434:2:2 6.42804:2:3 3.4014:2:4 -1.4655:2:5
     -3.11158:3:1 -3.11086:3:2 13.4434:3:3 4.65375:3:4 3.0695:3:5
     -3.11158:4:1 -3.11086:4:2 -3.11086:4:3 13.4434:4:4 2.86651:4:5
     -3.11086:5:1 -3.11013:5:2 -3.11013:5:3 -3.11013:5:4 13.4449:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.66633:1:1 -0.848692:1:2 -0.848692:1:3 -0.848692:1:4 -0.848494:1:5
     8.19625:2:1 3.56695:2:2 -1.07406:2:3 -1.07406:2:4 -1.07381:2:5
     13.4434:3:1 6.42804:3:2 3.4014:3:3 -1.4655:3:4 -1.46516:3:5
     -3.11086:4:1 13.4434:4:2 4.65375:4:3 3.0695:4:4 -2.3231:4:5
     -3.11086:5:1 -3.11086:5:2 13.4434:5:3 2.86651:5:4 2.00709:5:5

(5) 5.-1: "SetDBoundsStd"

(5) 5: "TangentialStep"

qp_grad_k = 
  5
   0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257422:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 1.4826932622e-008

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 2.5754814772e-001

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 2.5754814772e-001

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 1
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 2.5753641905e-001
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 1
max(|lambda_breve(i)|)  = 6.2413617786e-005
min(|lambda_breve(i)|)  = 6.2413617786e-005

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 2.5753641905e-001
nu_k.nz()      = 1
max(|nu_k(i)|) = 6.2413617786e-005
||Zpz_k||2     = 5.7573213689e-001

pz_k = 
  5
   -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

(5) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (5.1616070223e-022)/(2.1569444240e-004 * 5.7573213689e-001 + 2.2250738585e-308)
  = 4.1564782216e-018

||d||inf = 2.5753643382e-001

(5) 7: "CalcReducedGradLagrangian"

rGL_k = 
  5
   0.257554:1 0.257488:2 0.257488:3 0.257488:4 0.257359:5

||rGL_k||inf = 2.5755370750e-001

(5) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.2575537223e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.0480533192e-001 > opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 6.1791102848e-003 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 1.6066000962e-005 > comp_tol = 1.0000000000e-006
step_err         = 2.0479159598e-001 > step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 5) :-(

(5) 9.-1: "LineSearchFullStep"

f_k        = 1.6574989579e-001
||c_k||inf = 6.1791102848e-003
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 1.7288455117e-005

f_kp1        = 4.3078479209e-009
||c_kp1||inf = 1.6001110173e-003

(5) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 6.0687208500e-003

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|        1.6574983511e-001         6.0686601628e-003|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 4.3078479209e-009 1.5716730031e-003        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 4.3078479209e-009 - 1.0000000000e-005*1.5716730031e-003 = -1.1408882110e-008
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*1.5716730031e-003 = 1.5716572864e-003

Removing from the filter the redundant point:
  f_with_boundary     = 1.6574983511e-001
  theta_with_boundary = 6.0686601628e-003
  iteration added     = 4

(6) 1: "EvalNewPoint"

||x_k||inf            = 1.7288455117e-005
||x(var_dep)_k||inf   = 1.6137749700e-006
||x(var_indep)_k||inf = 1.7288455117e-005

x(var_indep)_k = 
  5
   1.72885e-005:1 1.17603e-005:2 1.176e-005:3 1.17596e-005:4 1e-005:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 4.3078479209e-009
||Gf_k||inf              = 1.7288455117e-005
||Gf_k(var_dep)_k||inf   = 1.6137749700e-006
||Gf_k(var_indep)_k||inf = 1.7288455117e-005
||c_k||inf               = 1.6001110173e-003

Gf(var_indep)_k =
  5
   1.72885e-005:1 1.17603e-005:2 1.176e-005:3 1.17596e-005:4 1e-005:5

(6) 2: "QuasiNormalStep"

||py||   = 1.6137749599e-006

||Ypy||2 = 8.8328450816e-005

(6) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 1.0085393716e-003

(6) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 1.5178830415e-018 / (1.6001110173e-003 + 2.2250738585e-308)
     = 9.4861108079e-016

(6) 3: "ReducedGradient"

||rGf||inf = 1.7285338958e-005

rGf_k =
  5
   1.72853e-005:1 1.17572e-005:2 1.17568e-005:3 1.17565e-005:4 9.99687e-006:5

(6) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(5.7573220998e-001+3.3239761380e-001))
        * (5.7573213689e-001/2.1569444240e-004)
      = 2.8009641333e+004
ratio > 1
Perform BFGS update if you can ...

(6) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.5753642216e-001

||s_bfgs||inf = 2.5753641905e-001

y_bfgs =
  5
   -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

s_bfgs =
  5
   -0.257536:1 -0.257476:2 -0.257476:3 -0.257476:4 -0.257412:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 3.3146748967e-001 >=  s_bfgs' * B * s_bfgs = 3.3146752990e-001
Perform the undamped update ...

B after the BFGS update = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.442:1:1 8.19621:1:2 3.56695:1:3 -1.07407:1:4 -1.07407:1:5
     -3.11161:2:1 13.4434:2:2 6.428:2:3 3.4014:2:4 -1.46552:2:5
     -3.11161:3:1 -3.11088:3:2 13.4434:3:3 4.65371:3:4 3.06949:3:5
     -3.11161:4:1 -3.11088:4:2 -3.11088:4:3 13.4434:4:4 2.86646:4:5
     -3.11083:5:1 -3.1101:5:2 -3.1101:5:3 -3.1101:5:4 13.445:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.66633:1:1 -0.848699:1:2 -0.848699:1:3 -0.848699:1:4 -0.848487:1:5
     8.19621:2:1 3.56695:2:2 -1.07407:2:3 -1.07407:2:4 -1.07381:2:5
     13.4434:3:1 6.428:3:2 3.4014:3:3 -1.46552:3:4 -1.46515:3:5
     -3.11088:4:1 13.4434:4:2 4.65371:4:3 3.06949:4:4 -2.32311:4:5
     -3.11088:5:1 -3.11088:5:2 13.4434:5:3 2.86646:5:4 2.0071:5:5

||rHL_k||inf    = 2.5886103889e+001

cond_inf(rHL_k) = 2.5891882950e+001

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     13.442:1:1 8.19621:1:2 3.56695:1:3 -1.07407:1:4 -1.07407:1:5
     -3.11161:2:1 13.4434:2:2 6.428:2:3 3.4014:2:4 -1.46552:2:5
     -3.11161:3:1 -3.11088:3:2 13.4434:3:3 4.65371:3:4 3.06949:3:5
     -3.11161:4:1 -3.11088:4:2 -3.11088:4:3 13.4434:4:4 2.86646:4:5
     -3.11083:5:1 -3.1101:5:2 -3.1101:5:3 -3.1101:5:4 13.445:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.66633:1:1 -0.848699:1:2 -0.848699:1:3 -0.848699:1:4 -0.848487:1:5
     8.19621:2:1 3.56695:2:2 -1.07407:2:3 -1.07407:2:4 -1.07381:2:5
     13.4434:3:1 6.428:3:2 3.4014:3:3 -1.46552:3:4 -1.46515:3:5
     -3.11088:4:1 13.4434:4:2 4.65371:4:3 3.06949:4:4 -2.32311:4:5
     -3.11088:5:1 -3.11088:5:2 13.4434:5:3 2.86646:5:4 2.0071:5:5

(6) 5.-1: "SetDBoundsStd"

(6) 5: "TangentialStep"

qp_grad_k = 
  5
   1.72853e-005:1 1.17572e-005:2 1.17568e-005:3 1.17565e-005:4 9.99687e-006:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 3.1252363232e-009

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 1.2802099303e-005

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 1.2802099303e-005

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 4
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 2.5052443220e-006
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 4
max(|lambda_breve(i)|)  = 3.4224117744e-005
min(|lambda_breve(i)|)  = 6.8491983462e-006

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 2.5052443220e-006
nu_k.nz()      = 4
max(|nu_k(i)|) = 3.4224117744e-005
||Zpz_k||2     = 3.9415350434e-006

pz_k = 
  5
   -2.50524e-006:1 -1.75722e-006:2 -1.75684e-006:3 -1.75645e-006:4 3.12524e-009:5

(6) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (1.8893372754e-028)/(8.8328450816e-005 * 3.9415350434e-006 + 2.2250738585e-308)
  = 5.4267958900e-019

||d||inf = 2.5083604809e-006

(6) 7: "CalcReducedGradLagrangian"

rGL_k = 
  5
   1.72853e-005:1 4.90802e-006:2 4.90168e-006:3 4.89533e-006:4 -2.42272e-005:5

||rGL_k||inf = 2.4227242980e-005

(6) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.0000172885e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 2.4226824136e-005 < opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 1.6001110173e-003 > feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 1.2072668759e-011 < comp_tol = 1.0000000000e-006
step_err         = 2.5083171159e-006 < step_tol = 1.0000000000e-002

Have not found the solution yet, have to keep going (k = 6) :-(

(6) 9.-1: "LineSearchFullStep"

f_k        = 4.3078479209e-009
||c_k||inf = 1.6001110173e-003
alpha_k    = 1.0000000000e+000

||x_kp1||inf   = 1.4780094636e-005

f_kp1        = 3.0922559878e-010
||c_kp1||inf = 7.9473675344e-009

(6) 9: "LineSearch"

theta_k = ||c_k||1/c_k.dim() = 1.5716730031e-003

f_min==F_MIN_UNBOUNDED:  Setting gamma_f_used = gamma_f = 1.0000000000e-005.

Beginning Filter line search method.

Current Filter
-----------------------------------------------------
|     f_with_boundary     |  theta_with_boundary    |
-----------------------------------------------------
|       -1.1408882110e-008         1.5716572864e-003|

  Iteration Status
----------------------------------------------------------------------------------------------------------
|    alpha_k    |     f_kp1     |   theta_kp1   |  pt. status   |                 comment                |
----------------------------------------------------------------------------------------------------------
|1.0000000000e+000 3.0922559878e-010 4.8949810735e-009        accepted      Fraction Reduction (! Switch Cond )|

Point was accepted - augmenting the filter ...

Augmenting the filter with the point:
  f_with_boundary = f_kp1 - gamma_f_used*theta_kp1 = 3.0922559878e-010 - 1.0000000000e-005*4.8949810735e-009 = 3.0917664897e-010
  theta_with_boundary = (1-gamma_theta)*theta_kp1 = (1-1.0000000000e-005)*4.8949810735e-009 = 4.8949321237e-009

(7) 1: "EvalNewPoint"

||x_k||inf            = 1.4780094636e-005
||x(var_dep)_k||inf   = 8.0843549152e-012
||x(var_indep)_k||inf = 1.4780094636e-005

x(var_indep)_k = 
  5
   1.47801e-005:1 1e-005:2 1e-005:3 1e-005:4 1e-005:5

Updating the decomposition ...

Updating the range/null decompostion matrices ...

***********************************************************
*** DecompositionSystemVarReductImp::update_decomp(...) ***
************************************************************

Warning!!! mat_rel != MATRICES_INDEP_IMPS; The decompsition matrix objects may not be independent of each other!

****************************************************************
*** DecompositionSystemVarReductImp::get_basis_matrices(...) ***
****************************************************************

Allocated a new explicit matrix object for D = -inv(C)*N of type 'class AbstractLinAlgPack::MultiVectorMutableDense' ...

End DecompositionSystemVarReductImp::get_basis_matrices(...)

Updating the basis matrix C and other matices using the BasisSystem object ...

Using a direct sparse solver to update basis ...

Using LAPACK xGETRF to refactor the basis matrix ...

End DecompositionSystemVarReductImp::update_decomp(...)

Printing the updated iteration quantities ...

f_k                      = 3.0922559878e-010
||Gf_k||inf              = 1.4780094636e-005
||Gf_k(var_dep)_k||inf   = 8.0843549152e-012
||Gf_k(var_indep)_k||inf = 1.4780094636e-005
||c_k||inf               = 7.9473675344e-009

Gf(var_indep)_k =
  5
   1.47801e-005:1 1e-005:2 1e-005:3 1e-005:4 1e-005:5

(7) 2: "QuasiNormalStep"

||py||   = 8.0843549152e-012

||Ypy||2 = 3.1177993329e-010

(7) 2.1: "CheckDecompositionFromPy"

beta = ||py||/||c|| = 1.0172368247e-003

(7) 2.2: "CheckDecompositionFromRPy"

beta = ||R*py_k + c_k(decomp)||inf / (||c_k(decomp)||inf + small_number)
     = 6.6174449004e-024 / (7.9473675344e-009 + 2.2250738585e-308)
     = 8.3265872275e-016

(7) 3: "ReducedGradient"

||rGf||inf = 1.4780094636e-005

rGf_k =
  5
   1.47801e-005:1 1e-005:2 1e-005:3 1e-005:4 1e-005:5

(7) 4.-1: "CheckSkipBFGSUpdate"

ratio = (skip_bfgs_prop_const/sqrt(||rGL_km1||+||c_km1||))*(||Zpz_km1||/||Ypy_km1||)
      = (1.0000000000e+001/sqrt(3.0948692947e-005+8.6084094835e-002))
        * (3.9415350434e-006/8.8328450816e-005)
      = 1.5206359933e+000
ratio > 1
Perform BFGS update if you can ...

(7) 4: "ReducedHessian"

Performing Secant update ...

||y_bfgs||inf = 2.5052443220e-006

||s_bfgs||inf = 2.5052443220e-006

y_bfgs =
  5
   -2.50524e-006:1 -1.75722e-006:2 -1.75684e-006:3 -1.75645e-006:4 3.12524e-009:5

s_bfgs =
  5
   -2.50524e-006:1 -1.75722e-006:2 -1.75684e-006:3 -1.75645e-006:4 3.12524e-009:5

Considering the dampened update ...

s_bfgs'*y_bfgs = 1.5535698402e-011 >=  s_bfgs' * B * s_bfgs = 6.9214067480e-011
Perform the undamped update ...

B after the BFGS update = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     9.52915:1:1 4.85671:1:2 3.40139:1:3 -1.46521:1:4 -1.4649:1:5
     -4.05396:2:1 13.2941:2:2 4.64731:2:3 3.06997:2:4 -2.32186:2:5
     -4.05244:3:1 -3.25975:3:2 13.295:3:3 2.86352:3:4 2.00916:3:5
     -4.05091:4:1 -3.25934:4:2 -3.25893:4:3 13.2958:4:4 0.00177507:4:5
     2.93911:5:1 -1.39248:5:2 -1.3947:5:3 -1.39693:5:4 4.96462:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.08693:1:1 -1.31326:1:2 -1.31277:1:3 -1.31228:1:4 0.952114:1:5
     4.85671:2:1 3.40139:2:2 -1.46521:2:3 -1.4649:2:4 -0.0417781:2:5
     13.2941:3:1 4.64731:3:2 3.06997:3:3 -2.32186:3:4 -0.0671046:3:5
     -3.25975:4:1 13.295:4:2 2.86352:4:3 2.00916:4:4 -0.181417:4:5
     -3.25934:5:1 -3.25893:5:2 13.2958:5:3 0.00177507:5:4 2.00473:5:5

||rHL_k||inf    = 2.4625571263e+001

cond_inf(rHL_k) = 3.1556895451e+001

rHL_k = 
  Unfactored symmetric matrix stored as lower triangle (ignore upper nonzeros):
    5 5
     9.52915:1:1 4.85671:1:2 3.40139:1:3 -1.46521:1:4 -1.4649:1:5
     -4.05396:2:1 13.2941:2:2 4.64731:2:3 3.06997:2:4 -2.32186:2:5
     -4.05244:3:1 -3.25975:3:2 13.295:3:3 2.86352:3:4 2.00916:3:5
     -4.05091:4:1 -3.25934:4:2 -3.25893:4:3 13.2958:4:4 0.00177507:4:5
     2.93911:5:1 -1.39248:5:2 -1.3947:5:3 -1.39693:5:4 4.96462:5:5
  Matrix scaling M = scale*U'*U, scale = 1
  Upper cholesky factor U (ignore lower nonzeros):
    5 5
     3.08693:1:1 -1.31326:1:2 -1.31277:1:3 -1.31228:1:4 0.952114:1:5
     4.85671:2:1 3.40139:2:2 -1.46521:2:3 -1.4649:2:4 -0.0417781:2:5
     13.2941:3:1 4.64731:3:2 3.06997:3:3 -2.32186:3:4 -0.0671046:3:5
     -3.25975:4:1 13.295:4:2 2.86352:4:3 2.00916:4:4 -0.181417:4:5
     -3.25934:5:1 -3.25893:5:2 13.2958:5:3 0.00177507:5:4 2.00473:5:5

(7) 5.-1: "SetDBoundsStd"

(7) 5: "TangentialStep"

qp_grad_k = 
  5
   1.47801e-005:1 1e-005:2 1e-005:3 1e-005:4 1e-005:5

Determine if we can use simple bounds on pz ...
    m = 3000
    dynamic_cast<const MatrixIdentConcat*>(&Z_k) = 00D2EBE0
    ||Ypy_k(var_indep)||inf = 7.8420208896e-020

Using bounds on full Z*pz ...

There are no finite bounds on dependent variables.  There will be no extra inequality constraints added on D*pz ...

*** Entering QPSchur::solve_qp(...)

*** Warm start info

Number of variables                                          = 6
Number of initially fixed variables (not in Ko)              = 1
Number of changes to the initial KKT system (num_act_change) = 0

    Number of initially fixed variables freed from a bound   = 0
    Number of initially free variables fixed to a bound      = 0
    Number of general equality constraints added             = 0
    Number of general inequality constraints added           = 0

Solution to the initial KKT system, vo = inv(Ko)*fo:

||vo||inf = 1.4012954527e-005

***
*** Removing constriants until we are dual feasible
***

*** Start by removing constraints within the Schur complement first

There where 0 constraints dropped from the schur complement from the initial guess of the active set.

Current guess for unknowns x:

||x||inf = 1.4012954527e-005

*** Second, free initially fixed variables not in Ko

There where 0 initially fixed variables not in Ko that were freed and added to the schur complement.

*** Starting Primal-Dual Iterations ***

We think we have found the solution and are not currently using iterative refinement
and iter_refine_at_solution==true so perform iterative refinement ...

Iterative refinement did not alter the unknowns so exit with this solution...

Recomputing final mu_D_hat at the solution ...

*** Solution found!

Number of QP iteratons                                = 4
Number of iterative refinement residual calculations  = 1
Number of iterative refinement solves                 = 0

||x||inf                = 1.5510400570e-006
mu.nz()                 = 1
max(|mu(i)|)            = 1.0000000000e+010
min(|mu(i)|)            = 1.0000000000e+010
lambda_breve.nz()       = 4
max(|lambda_breve(i)|)  = 1.6287853297e-005
min(|lambda_breve(i)|)  = 5.4413183995e-006

*** Leaving QPSchur::solve_qp(...)

||pz_k||inf    = 1.5510400570e-006
nu_k.nz()      = 4
max(|nu_k(i)|) = 1.6287853297e-005
||Zpz_k||2     = 1.5510400570e-006

pz_k = 
  5
   -1.55104e-006:1 4.05368e-020:2 3.85338e-020:3 4.15964e-020:4 1.59273e-021:5

(7) 6: "CalcDFromYPYZPZ"

(Ypy_k'*Zpz_k)/(||Ypy_k||2 * ||Zpz_k||2 + eps)
  = (-4.2980598113e-039)/(3.1177993329e-010 * 1.5510400570e-006 + 2.2250738585e-308)
  = -8.8879434145e-024

||d||inf = 1.5510400570e-006

(7) 7: "CalcReducedGradLagrangian"

rGL_k = 
  5
   1.47801e-005:1 -6.28785e-006:2 -6.28549e-006:3 -6.28313e-006:4 4.55868e-006:5

||rGL_k||inf = 1.4780094636e-005

(7) 8: "CheckConvergence"

scale_opt_factor = 1.0000000000e+000 (scale_opt_error_by = SCALE_BY_ONE)
scale_feas_factor = 1.0000000000e+000 (scale_feas_error_by = SCALE_BY_ONE)
scale_comp_factor = 1.0000000000e+000 (scale_comp_error_by = SCALE_BY_ONE)
opt_scale_factor = 1.0000147801e+000 (scale_opt_error_by_Gf = true)
opt_kkt_err_k    = 1.4779876188e-005 < opt_tol  = 1.0000000000e-002
feas_kkt_err_k   = 7.9473675344e-009 < feas_tol = 1.0000000000e-007
comp_kkt_err_k   = 0.0000000000e+000 < comp_tol = 1.0000000000e-006
step_err         = 1.5510171329e-006 < step_tol = 1.0000000000e-002

Jackpot!  Found the solution!!!!!! (k = 7)
